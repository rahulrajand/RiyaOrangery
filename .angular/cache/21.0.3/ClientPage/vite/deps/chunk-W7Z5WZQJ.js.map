{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ng-bootstrap/ng-bootstrap/fesm2022/ng-bootstrap-ng-bootstrap-scrollspy.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { Injectable, inject, DOCUMENT, PLATFORM_ID, ChangeDetectorRef, NgZone, DestroyRef, Input, Directive, ContentChildren, ElementRef, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { isString } from './_ngb-ngbootstrap-utilities.mjs';\nimport { isPlatformBrowser } from '@angular/common';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nfunction toFragmentElement(container, id) {\n  if (!container || id == null) {\n    return null;\n  }\n  return isString(id) ? container.querySelector(`#${CSS.escape(id)}`) : id;\n}\nfunction getOrderedFragments(container, fragments) {\n  const selector = [...fragments].map(({\n    id\n  }) => `#${CSS.escape(id)}`).join(',');\n  return Array.from(container.querySelectorAll(selector));\n}\nconst defaultProcessChanges = (state, changeActive, ctx) => {\n  const {\n    rootElement,\n    fragments,\n    scrollSpy,\n    options,\n    entries\n  } = state;\n  const orderedFragments = getOrderedFragments(rootElement, fragments);\n  if (!ctx.initialized) {\n    ctx.initialized = true;\n    ctx.gapFragment = null;\n    ctx.visibleFragments = new Set();\n    // special case when one of the fragments was pre-selected\n    const preSelectedFragment = toFragmentElement(rootElement, options?.initialFragment);\n    if (preSelectedFragment) {\n      scrollSpy.scrollTo(preSelectedFragment);\n      return;\n    }\n  }\n  for (const entry of entries) {\n    const {\n      isIntersecting,\n      target: fragment\n    } = entry;\n    // 1. an entry became visible\n    if (isIntersecting) {\n      // if we were in-between two elements, we have to clear it up\n      if (ctx.gapFragment) {\n        ctx.visibleFragments.delete(ctx.gapFragment);\n        ctx.gapFragment = null;\n      }\n      ctx.visibleFragments.add(fragment);\n    }\n    // 2. an entry became invisible\n    else {\n      ctx.visibleFragments.delete(fragment);\n      // nothing is visible anymore, but something just was actually\n      if (ctx.visibleFragments.size === 0 && scrollSpy.active !== '') {\n        // 2.1 scrolling down - keeping the same element\n        if (entry.boundingClientRect.top < entry.rootBounds.top) {\n          ctx.gapFragment = fragment;\n          ctx.visibleFragments.add(ctx.gapFragment);\n        }\n        // 2.2 scrolling up - getting the previous element\n        else {\n          // scrolling up and no more fragments above\n          if (fragment === orderedFragments[0]) {\n            ctx.gapFragment = null;\n            ctx.visibleFragments.clear();\n            changeActive('');\n            return;\n          }\n          // getting previous fragment\n          else {\n            const fragmentIndex = orderedFragments.indexOf(fragment);\n            ctx.gapFragment = orderedFragments[fragmentIndex - 1] || null;\n            if (ctx.gapFragment) {\n              ctx.visibleFragments.add(ctx.gapFragment);\n            }\n          }\n        }\n      }\n    }\n  }\n  // getting the first visible element in the DOM order of the fragments\n  for (const fragment of orderedFragments) {\n    if (ctx.visibleFragments.has(fragment)) {\n      changeActive(fragment.id);\n      break;\n    }\n  }\n};\n\n/**\n * A configuration service for the [`NgbScrollSpyService`](#/components/scrollspy/api#NgbScrollSpyService).\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all scrollspies used in the application.\n *\n * @since 15.1.0\n */\nclass NgbScrollSpyConfig {\n  constructor() {\n    this.scrollBehavior = 'smooth';\n    this.processChanges = defaultProcessChanges;\n  }\n  static {\n    this.ɵfac = function NgbScrollSpyConfig_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyConfig)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbScrollSpyConfig,\n      factory: NgbScrollSpyConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nconst MATCH_THRESHOLD = 3;\n/**\n * A scrollspy service that allows tracking of elements scrolling in and out of view.\n *\n * It can be instantiated manually, or automatically by the `ngbScrollSpy` directive.\n *\n * @since 15.1.0\n */\nclass NgbScrollSpyService {\n  constructor() {\n    this._observer = null;\n    this._containerElement = null;\n    this._fragments = new Set();\n    this._preRegisteredFragments = new Set();\n    this._active$ = new Subject();\n    this._distinctActive$ = this._active$.pipe(distinctUntilChanged());\n    this._active = '';\n    this._config = inject(NgbScrollSpyConfig);\n    this._document = inject(DOCUMENT);\n    this._platformId = inject(PLATFORM_ID);\n    this._scrollBehavior = this._config.scrollBehavior;\n    this._diChangeDetectorRef = inject(ChangeDetectorRef, {\n      optional: true\n    });\n    this._changeDetectorRef = this._diChangeDetectorRef;\n    this._zone = inject(NgZone);\n    this._distinctActive$.pipe(takeUntilDestroyed()).subscribe(active => {\n      this._active = active;\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n  /**\n   * Getter for the currently active fragment id. Returns empty string if none.\n   */\n  get active() {\n    return this._active;\n  }\n  /**\n   * An observable emitting the currently active fragment. Emits empty string if none.\n   */\n  get active$() {\n    return this._distinctActive$;\n  }\n  /**\n   * Starts the scrollspy service and observes specified fragments.\n   *\n   * You can specify a list of options to pass, like the root element, initial fragment, scroll behavior, etc.\n   * See the [`NgbScrollSpyOptions`](#/components/scrollspy/api#NgbScrollSpyOptions) interface for more details.\n   */\n  start(options) {\n    if (isPlatformBrowser(this._platformId)) {\n      this._cleanup();\n      const {\n        root,\n        rootMargin,\n        scrollBehavior,\n        threshold,\n        fragments,\n        changeDetectorRef,\n        processChanges\n      } = {\n        ...options\n      };\n      this._containerElement = root ?? this._document.documentElement;\n      this._changeDetectorRef = changeDetectorRef ?? this._diChangeDetectorRef;\n      this._scrollBehavior = scrollBehavior ?? this._config.scrollBehavior;\n      const processChangesFn = processChanges ?? this._config.processChanges;\n      const context = {};\n      this._observer = new IntersectionObserver(entries => processChangesFn({\n        entries,\n        rootElement: this._containerElement,\n        fragments: this._fragments,\n        scrollSpy: this,\n        options: {\n          ...options\n        }\n      }, active => this._active$.next(active), context), {\n        root: root ?? this._document,\n        ...(rootMargin && {\n          rootMargin\n        }),\n        ...(threshold && {\n          threshold\n        })\n      });\n      // merging fragments added before starting and the ones passed as options\n      for (const element of [...this._preRegisteredFragments, ...(fragments ?? [])]) {\n        this.observe(element);\n      }\n      this._preRegisteredFragments.clear();\n    }\n  }\n  /**\n   * Stops the service and unobserves all fragments.\n   */\n  stop() {\n    this._cleanup();\n    this._active$.next('');\n  }\n  /**\n   * Scrolls to a fragment, it must be known to the service and contained in the root element.\n   * An id or an element reference can be passed.\n   *\n   * [`NgbScrollToOptions`](#/components/scrollspy/api#NgbScrollToOptions) can be passed.\n   */\n  scrollTo(fragment, options) {\n    const {\n      behavior\n    } = {\n      behavior: this._scrollBehavior,\n      ...options\n    };\n    if (this._containerElement) {\n      const fragmentElement = toFragmentElement(this._containerElement, fragment);\n      if (fragmentElement) {\n        const heightPx = fragmentElement.offsetTop - this._containerElement.offsetTop;\n        this._containerElement.scrollTo({\n          top: heightPx,\n          behavior\n        });\n        let lastOffset = this._containerElement.scrollTop;\n        let matchCounter = 0;\n        // we should update the active section only after scrolling is finished\n        // and there is no clean way to do it at the moment\n        const containerElement = this._containerElement;\n        this._zone.runOutsideAngular(() => {\n          const updateActiveWhenScrollingIsFinished = () => {\n            const sameOffsetAsLastTime = lastOffset === containerElement.scrollTop;\n            if (sameOffsetAsLastTime) {\n              matchCounter++;\n            } else {\n              matchCounter = 0;\n            }\n            if (!sameOffsetAsLastTime || sameOffsetAsLastTime && matchCounter < MATCH_THRESHOLD) {\n              lastOffset = containerElement.scrollTop;\n              requestAnimationFrame(updateActiveWhenScrollingIsFinished);\n            } else {\n              this._zone.run(() => this._active$.next(fragmentElement.id));\n            }\n          };\n          requestAnimationFrame(updateActiveWhenScrollingIsFinished);\n        });\n      }\n    }\n  }\n  /**\n   * Adds a fragment to observe. It must be contained in the root element.\n   * An id or an element reference can be passed.\n   */\n  observe(fragment) {\n    if (!this._observer) {\n      this._preRegisteredFragments.add(fragment);\n      return;\n    }\n    const fragmentElement = toFragmentElement(this._containerElement, fragment);\n    if (fragmentElement && !this._fragments.has(fragmentElement)) {\n      this._fragments.add(fragmentElement);\n      this._observer.observe(fragmentElement);\n    }\n  }\n  /**\n   * Unobserves a fragment.\n   * An id or an element reference can be passed.\n   */\n  unobserve(fragment) {\n    if (!this._observer) {\n      this._preRegisteredFragments.delete(fragment);\n      return;\n    }\n    const fragmentElement = toFragmentElement(this._containerElement, fragment);\n    if (fragmentElement) {\n      this._fragments.delete(fragmentElement);\n      // we're removing and re-adding all current fragments to recompute active one\n      this._observer.disconnect();\n      for (const fragment of this._fragments) {\n        this._observer.observe(fragment);\n      }\n    }\n  }\n  ngOnDestroy() {\n    this._cleanup();\n  }\n  _cleanup() {\n    this._fragments.clear();\n    this._observer?.disconnect();\n    this._changeDetectorRef = this._diChangeDetectorRef;\n    this._scrollBehavior = this._config.scrollBehavior;\n    this._observer = null;\n    this._containerElement = null;\n  }\n  static {\n    this.ɵfac = function NgbScrollSpyService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyService)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbScrollSpyService,\n      factory: NgbScrollSpyService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * A helper directive to that links menu items and fragments together.\n *\n * It will automatically add the `.active` class to the menu item when the associated fragment becomes active.\n *\n * @since 15.1.0\n */\nclass NgbScrollSpyItem {\n  constructor() {\n    this._changeDetector = inject(ChangeDetectorRef);\n    this._scrollSpyMenu = inject(NgbScrollSpyMenu, {\n      optional: true\n    });\n    this._scrollSpyAPI = this._scrollSpyMenu ?? inject(NgbScrollSpyService);\n    this._destroyRef = inject(DestroyRef);\n    this._isActive = false;\n  }\n  /**\n   * References the scroll spy directive, the id of the associated fragment and the parent menu item.\n   *\n   * Can be used like:\n   *  - `ngbScrollSpyItem=\"fragmentId\"`\n   *  - `[ngbScrollSpyItem]=\"scrollSpy\" fragment=\"fragmentId\"\n   *  - `[ngbScrollSpyItem]=\"[scrollSpy, 'fragmentId']\"` parent=\"parentId\"`\n   *  - `[ngbScrollSpyItem]=\"[scrollSpy, 'fragmentId', 'parentId']\"`\n   *\n   *  As well as together with `[fragment]` and `[parent]` inputs.\n   */\n  set data(data) {\n    if (Array.isArray(data)) {\n      this._scrollSpyAPI = data[0];\n      this.fragment = data[1];\n      this.parent ??= data[2];\n    } else if (data instanceof NgbScrollSpy) {\n      this._scrollSpyAPI = data;\n    } else if (isString(data)) {\n      this.fragment = data;\n    }\n  }\n  ngOnInit() {\n    // if it is not a part of a bigger menu, it should handle activation itself\n    if (!this._scrollSpyMenu) {\n      this._scrollSpyAPI.active$.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(active => {\n        if (active === this.fragment) {\n          this._activate();\n        } else {\n          this._deactivate();\n        }\n        this._changeDetector.markForCheck();\n      });\n    }\n  }\n  /**\n   * @internal\n   */\n  _activate() {\n    this._isActive = true;\n    if (this._scrollSpyMenu) {\n      this._scrollSpyMenu.getItem(this.parent ?? '')?._activate();\n    }\n  }\n  /**\n   * @internal\n   */\n  _deactivate() {\n    this._isActive = false;\n    if (this._scrollSpyMenu) {\n      this._scrollSpyMenu.getItem(this.parent ?? '')?._deactivate();\n    }\n  }\n  /**\n   * Returns `true`, if the associated fragment is active.\n   */\n  isActive() {\n    return this._isActive;\n  }\n  /**\n   * Scrolls to the associated fragment.\n   */\n  scrollTo(options) {\n    this._scrollSpyAPI.scrollTo(this.fragment, options);\n  }\n  static {\n    this.ɵfac = function NgbScrollSpyItem_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyItem)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyItem,\n      selectors: [[\"\", \"ngbScrollSpyItem\", \"\"]],\n      hostVars: 2,\n      hostBindings: function NgbScrollSpyItem_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbScrollSpyItem_click_HostBindingHandler() {\n            return ctx.scrollTo();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"active\", ctx.isActive());\n        }\n      },\n      inputs: {\n        data: [0, \"ngbScrollSpyItem\", \"data\"],\n        fragment: \"fragment\",\n        parent: \"parent\"\n      },\n      exportAs: [\"ngbScrollSpyItem\"]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyItem, [{\n    type: Directive,\n    args: [{\n      selector: '[ngbScrollSpyItem]',\n      exportAs: 'ngbScrollSpyItem',\n      host: {\n        '[class.active]': 'isActive()',\n        '(click)': 'scrollTo();'\n      }\n    }]\n  }], null, {\n    data: [{\n      type: Input,\n      args: ['ngbScrollSpyItem']\n    }],\n    fragment: [{\n      type: Input\n    }],\n    parent: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * An optional scroll spy menu directive to build hierarchical menus\n * and simplify the [`NgbScrollSpyItem`](#/components/scrollspy/api#NgbScrollSpyItem) configuration.\n *\n * @since 15.1.0\n */\nclass NgbScrollSpyMenu {\n  constructor() {\n    this._scrollSpyRef = inject(NgbScrollSpyService);\n    this._destroyRef = inject(DestroyRef);\n    this._map = new Map();\n    this._lastActiveItem = null;\n  }\n  set scrollSpy(scrollSpy) {\n    this._scrollSpyRef = scrollSpy;\n  }\n  get active() {\n    return this._scrollSpyRef.active;\n  }\n  get active$() {\n    return this._scrollSpyRef.active$;\n  }\n  scrollTo(fragment, options) {\n    this._scrollSpyRef.scrollTo(fragment, options);\n  }\n  getItem(id) {\n    return this._map.get(id);\n  }\n  ngAfterViewInit() {\n    this._items.changes.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(() => this._rebuildMap());\n    this._rebuildMap();\n    this._scrollSpyRef.active$.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(activeId => {\n      this._lastActiveItem?._deactivate();\n      const item = this._map.get(activeId);\n      if (item) {\n        item._activate();\n        this._lastActiveItem = item;\n      }\n    });\n  }\n  _rebuildMap() {\n    this._map.clear();\n    for (let item of this._items) {\n      this._map.set(item.fragment, item);\n    }\n  }\n  static {\n    this.ɵfac = function NgbScrollSpyMenu_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyMenu)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyMenu,\n      selectors: [[\"\", \"ngbScrollSpyMenu\", \"\"]],\n      contentQueries: function NgbScrollSpyMenu_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbScrollSpyItem, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._items = _t);\n        }\n      },\n      inputs: {\n        scrollSpy: [0, \"ngbScrollSpyMenu\", \"scrollSpy\"]\n      }\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyMenu, [{\n    type: Directive,\n    args: [{\n      selector: '[ngbScrollSpyMenu]'\n    }]\n  }], null, {\n    _items: [{\n      type: ContentChildren,\n      args: [NgbScrollSpyItem, {\n        descendants: true\n      }]\n    }],\n    scrollSpy: [{\n      type: Input,\n      args: ['ngbScrollSpyMenu']\n    }]\n  });\n})();\n/**\n * A directive to put on a scrollable container.\n *\n * It will instantiate a [`NgbScrollSpyService`](#/components/scrollspy/api#NgbScrollSpyService).\n *\n * @since 15.1.0\n */\nclass NgbScrollSpy {\n  constructor() {\n    this._initialFragment = null;\n    this._service = inject(NgbScrollSpyService);\n    this._nativeElement = inject(ElementRef).nativeElement;\n    /**\n     * An event raised when the active section changes.\n     *\n     * Payload is the id of the new active section, empty string if none.\n     */\n    this.activeChange = this._service.active$;\n  }\n  set active(fragment) {\n    this._initialFragment = fragment;\n    this.scrollTo(fragment);\n  }\n  /**\n   * Getter/setter for the currently active fragment id.\n   */\n  get active() {\n    return this._service.active;\n  }\n  /**\n   * Returns an observable that emits currently active section id.\n   */\n  get active$() {\n    return this._service.active$;\n  }\n  ngAfterViewInit() {\n    this._service.start({\n      processChanges: this.processChanges,\n      root: this._nativeElement,\n      rootMargin: this.rootMargin,\n      threshold: this.threshold,\n      ...(this._initialFragment && {\n        initialFragment: this._initialFragment\n      })\n    });\n  }\n  /**\n   * @internal\n   */\n  _registerFragment(fragment) {\n    this._service.observe(fragment.id);\n  }\n  /**\n   * @internal\n   */\n  _unregisterFragment(fragment) {\n    this._service.unobserve(fragment.id);\n  }\n  /**\n   * Scrolls to a fragment that is identified by the `ngbScrollSpyFragment` directive.\n   * An id or an element reference can be passed.\n   */\n  scrollTo(fragment, options) {\n    this._service.scrollTo(fragment, {\n      ...(this.scrollBehavior && {\n        behavior: this.scrollBehavior\n      }),\n      ...options\n    });\n  }\n  static {\n    this.ɵfac = function NgbScrollSpy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpy)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpy,\n      selectors: [[\"\", \"ngbScrollSpy\", \"\"]],\n      hostAttrs: [\"tabindex\", \"0\", 2, \"overflow-y\", \"auto\"],\n      inputs: {\n        processChanges: \"processChanges\",\n        rootMargin: \"rootMargin\",\n        scrollBehavior: \"scrollBehavior\",\n        threshold: \"threshold\",\n        active: \"active\"\n      },\n      outputs: {\n        activeChange: \"activeChange\"\n      },\n      exportAs: [\"ngbScrollSpy\"],\n      features: [i0.ɵɵProvidersFeature([NgbScrollSpyService])]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpy, [{\n    type: Directive,\n    args: [{\n      selector: '[ngbScrollSpy]',\n      exportAs: 'ngbScrollSpy',\n      host: {\n        tabindex: '0',\n        style: 'overflow-y: auto'\n      },\n      providers: [NgbScrollSpyService]\n    }]\n  }], null, {\n    processChanges: [{\n      type: Input\n    }],\n    rootMargin: [{\n      type: Input\n    }],\n    scrollBehavior: [{\n      type: Input\n    }],\n    threshold: [{\n      type: Input\n    }],\n    active: [{\n      type: Input\n    }],\n    activeChange: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * A directive to put on a fragment observed inside a scrollspy container.\n *\n * @since 15.1.0\n */\nclass NgbScrollSpyFragment {\n  constructor() {\n    this._destroyRef = inject(DestroyRef);\n    this._scrollSpy = inject(NgbScrollSpy);\n  }\n  ngAfterViewInit() {\n    this._scrollSpy._registerFragment(this);\n    this._destroyRef.onDestroy(() => this._scrollSpy._unregisterFragment(this));\n  }\n  static {\n    this.ɵfac = function NgbScrollSpyFragment_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyFragment)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyFragment,\n      selectors: [[\"\", \"ngbScrollSpyFragment\", \"\"]],\n      hostVars: 1,\n      hostBindings: function NgbScrollSpyFragment_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"id\", ctx.id);\n        }\n      },\n      inputs: {\n        id: [0, \"ngbScrollSpyFragment\", \"id\"]\n      }\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyFragment, [{\n    type: Directive,\n    args: [{\n      selector: '[ngbScrollSpyFragment]',\n      host: {\n        '[id]': 'id'\n      }\n    }]\n  }], null, {\n    id: [{\n      type: Input,\n      args: ['ngbScrollSpyFragment']\n    }]\n  });\n})();\nclass NgbScrollSpyModule {\n  static {\n    this.ɵfac = function NgbScrollSpyModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgbScrollSpyModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbScrollSpyModule,\n      imports: [NgbScrollSpy, NgbScrollSpyItem, NgbScrollSpyFragment, NgbScrollSpyMenu],\n      exports: [NgbScrollSpy, NgbScrollSpyItem, NgbScrollSpyFragment, NgbScrollSpyMenu]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgbScrollSpyModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgbScrollSpy, NgbScrollSpyItem, NgbScrollSpyFragment, NgbScrollSpyMenu],\n      exports: [NgbScrollSpy, NgbScrollSpyItem, NgbScrollSpyFragment, NgbScrollSpyMenu]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgbScrollSpy, NgbScrollSpyConfig, NgbScrollSpyFragment, NgbScrollSpyItem, NgbScrollSpyMenu, NgbScrollSpyModule, NgbScrollSpyService };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,SAAS,kBAAkB,WAAW,IAAI;AACxC,MAAI,CAAC,aAAa,MAAM,MAAM;AAC5B,WAAO;AAAA,EACT;AACA,SAAO,SAAS,EAAE,IAAI,UAAU,cAAc,IAAI,IAAI,OAAO,EAAE,CAAC,EAAE,IAAI;AACxE;AACA,SAAS,oBAAoB,WAAW,WAAW;AACjD,QAAM,WAAW,CAAC,GAAG,SAAS,EAAE,IAAI,CAAC;AAAA,IACnC;AAAA,EACF,MAAM,IAAI,IAAI,OAAO,EAAE,CAAC,EAAE,EAAE,KAAK,GAAG;AACpC,SAAO,MAAM,KAAK,UAAU,iBAAiB,QAAQ,CAAC;AACxD;AACA,IAAM,wBAAwB,CAAC,OAAO,cAAc,QAAQ;AAC1D,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,mBAAmB,oBAAoB,aAAa,SAAS;AACnE,MAAI,CAAC,IAAI,aAAa;AACpB,QAAI,cAAc;AAClB,QAAI,cAAc;AAClB,QAAI,mBAAmB,oBAAI,IAAI;AAE/B,UAAM,sBAAsB,kBAAkB,aAAa,SAAS,eAAe;AACnF,QAAI,qBAAqB;AACvB,gBAAU,SAAS,mBAAmB;AACtC;AAAA,IACF;AAAA,EACF;AACA,aAAW,SAAS,SAAS;AAC3B,UAAM;AAAA,MACJ;AAAA,MACA,QAAQ;AAAA,IACV,IAAI;AAEJ,QAAI,gBAAgB;AAElB,UAAI,IAAI,aAAa;AACnB,YAAI,iBAAiB,OAAO,IAAI,WAAW;AAC3C,YAAI,cAAc;AAAA,MACpB;AACA,UAAI,iBAAiB,IAAI,QAAQ;AAAA,IACnC,OAEK;AACH,UAAI,iBAAiB,OAAO,QAAQ;AAEpC,UAAI,IAAI,iBAAiB,SAAS,KAAK,UAAU,WAAW,IAAI;AAE9D,YAAI,MAAM,mBAAmB,MAAM,MAAM,WAAW,KAAK;AACvD,cAAI,cAAc;AAClB,cAAI,iBAAiB,IAAI,IAAI,WAAW;AAAA,QAC1C,OAEK;AAEH,cAAI,aAAa,iBAAiB,CAAC,GAAG;AACpC,gBAAI,cAAc;AAClB,gBAAI,iBAAiB,MAAM;AAC3B,yBAAa,EAAE;AACf;AAAA,UACF,OAEK;AACH,kBAAM,gBAAgB,iBAAiB,QAAQ,QAAQ;AACvD,gBAAI,cAAc,iBAAiB,gBAAgB,CAAC,KAAK;AACzD,gBAAI,IAAI,aAAa;AACnB,kBAAI,iBAAiB,IAAI,IAAI,WAAW;AAAA,YAC1C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,aAAW,YAAY,kBAAkB;AACvC,QAAI,IAAI,iBAAiB,IAAI,QAAQ,GAAG;AACtC,mBAAa,SAAS,EAAE;AACxB;AAAA,IACF;AAAA,EACF;AACF;AAUA,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EACvB,cAAc;AACZ,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AAAA,EACxB;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,2BAA2B,mBAAmB;AACjE,aAAO,KAAK,qBAAqB,qBAAoB;AAAA,IACvD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,QAA0B,mBAAmB;AAAA,MAChD,OAAO;AAAA,MACP,SAAS,oBAAmB;AAAA,MAC5B,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,oBAAoB,CAAC;AAAA,IAC3F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AACH,IAAM,kBAAkB;AAQxB,IAAM,sBAAN,MAAM,qBAAoB;AAAA,EACxB,cAAc;AACZ,SAAK,YAAY;AACjB,SAAK,oBAAoB;AACzB,SAAK,aAAa,oBAAI,IAAI;AAC1B,SAAK,0BAA0B,oBAAI,IAAI;AACvC,SAAK,WAAW,IAAI,QAAQ;AAC5B,SAAK,mBAAmB,KAAK,SAAS,KAAK,qBAAqB,CAAC;AACjE,SAAK,UAAU;AACf,SAAK,UAAU,OAAO,kBAAkB;AACxC,SAAK,YAAY,OAAO,QAAQ;AAChC,SAAK,cAAc,OAAO,WAAW;AACrC,SAAK,kBAAkB,KAAK,QAAQ;AACpC,SAAK,uBAAuB,OAAO,mBAAmB;AAAA,MACpD,UAAU;AAAA,IACZ,CAAC;AACD,SAAK,qBAAqB,KAAK;AAC/B,SAAK,QAAQ,OAAO,MAAM;AAC1B,SAAK,iBAAiB,KAAK,mBAAmB,CAAC,EAAE,UAAU,YAAU;AACnE,WAAK,UAAU;AACf,WAAK,oBAAoB,aAAa;AAAA,IACxC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS;AACb,QAAI,kBAAkB,KAAK,WAAW,GAAG;AACvC,WAAK,SAAS;AACd,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,mBACC;AAEL,WAAK,oBAAoB,QAAQ,KAAK,UAAU;AAChD,WAAK,qBAAqB,qBAAqB,KAAK;AACpD,WAAK,kBAAkB,kBAAkB,KAAK,QAAQ;AACtD,YAAM,mBAAmB,kBAAkB,KAAK,QAAQ;AACxD,YAAM,UAAU,CAAC;AACjB,WAAK,YAAY,IAAI,qBAAqB,aAAW,iBAAiB;AAAA,QACpE;AAAA,QACA,aAAa,KAAK;AAAA,QAClB,WAAW,KAAK;AAAA,QAChB,WAAW;AAAA,QACX,SAAS,mBACJ;AAAA,MAEP,GAAG,YAAU,KAAK,SAAS,KAAK,MAAM,GAAG,OAAO,GAAG;AAAA,QACjD,MAAM,QAAQ,KAAK;AAAA,SACf,cAAc;AAAA,QAChB;AAAA,MACF,IACI,aAAa;AAAA,QACf;AAAA,MACF,EACD;AAED,iBAAW,WAAW,CAAC,GAAG,KAAK,yBAAyB,GAAI,aAAa,CAAC,CAAE,GAAG;AAC7E,aAAK,QAAQ,OAAO;AAAA,MACtB;AACA,WAAK,wBAAwB,MAAM;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AACL,SAAK,SAAS;AACd,SAAK,SAAS,KAAK,EAAE;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,UAAU,SAAS;AAC1B,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AAAA,MACF,UAAU,KAAK;AAAA,OACZ;AAEL,QAAI,KAAK,mBAAmB;AAC1B,YAAM,kBAAkB,kBAAkB,KAAK,mBAAmB,QAAQ;AAC1E,UAAI,iBAAiB;AACnB,cAAM,WAAW,gBAAgB,YAAY,KAAK,kBAAkB;AACpE,aAAK,kBAAkB,SAAS;AAAA,UAC9B,KAAK;AAAA,UACL;AAAA,QACF,CAAC;AACD,YAAI,aAAa,KAAK,kBAAkB;AACxC,YAAI,eAAe;AAGnB,cAAM,mBAAmB,KAAK;AAC9B,aAAK,MAAM,kBAAkB,MAAM;AACjC,gBAAM,sCAAsC,MAAM;AAChD,kBAAM,uBAAuB,eAAe,iBAAiB;AAC7D,gBAAI,sBAAsB;AACxB;AAAA,YACF,OAAO;AACL,6BAAe;AAAA,YACjB;AACA,gBAAI,CAAC,wBAAwB,wBAAwB,eAAe,iBAAiB;AACnF,2BAAa,iBAAiB;AAC9B,oCAAsB,mCAAmC;AAAA,YAC3D,OAAO;AACL,mBAAK,MAAM,IAAI,MAAM,KAAK,SAAS,KAAK,gBAAgB,EAAE,CAAC;AAAA,YAC7D;AAAA,UACF;AACA,gCAAsB,mCAAmC;AAAA,QAC3D,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,UAAU;AAChB,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,wBAAwB,IAAI,QAAQ;AACzC;AAAA,IACF;AACA,UAAM,kBAAkB,kBAAkB,KAAK,mBAAmB,QAAQ;AAC1E,QAAI,mBAAmB,CAAC,KAAK,WAAW,IAAI,eAAe,GAAG;AAC5D,WAAK,WAAW,IAAI,eAAe;AACnC,WAAK,UAAU,QAAQ,eAAe;AAAA,IACxC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,UAAU;AAClB,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,wBAAwB,OAAO,QAAQ;AAC5C;AAAA,IACF;AACA,UAAM,kBAAkB,kBAAkB,KAAK,mBAAmB,QAAQ;AAC1E,QAAI,iBAAiB;AACnB,WAAK,WAAW,OAAO,eAAe;AAEtC,WAAK,UAAU,WAAW;AAC1B,iBAAWA,aAAY,KAAK,YAAY;AACtC,aAAK,UAAU,QAAQA,SAAQ;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAAA,EACA,cAAc;AACZ,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,WAAW;AACT,SAAK,WAAW,MAAM;AACtB,SAAK,WAAW,WAAW;AAC3B,SAAK,qBAAqB,KAAK;AAC/B,SAAK,kBAAkB,KAAK,QAAQ;AACpC,SAAK,YAAY;AACjB,SAAK,oBAAoB;AAAA,EAC3B;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,4BAA4B,mBAAmB;AAClE,aAAO,KAAK,qBAAqB,sBAAqB;AAAA,IACxD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,QAA0B,mBAAmB;AAAA,MAChD,OAAO;AAAA,MACP,SAAS,qBAAoB;AAAA,MAC7B,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,qBAAqB,CAAC;AAAA,IAC5F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI;AACpB,GAAG;AASH,IAAM,mBAAN,MAAM,kBAAiB;AAAA,EACrB,cAAc;AACZ,SAAK,kBAAkB,OAAO,iBAAiB;AAC/C,SAAK,iBAAiB,OAAO,kBAAkB;AAAA,MAC7C,UAAU;AAAA,IACZ,CAAC;AACD,SAAK,gBAAgB,KAAK,kBAAkB,OAAO,mBAAmB;AACtE,SAAK,cAAc,OAAO,UAAU;AACpC,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,KAAK,MAAM;AACb,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAK,gBAAgB,KAAK,CAAC;AAC3B,WAAK,WAAW,KAAK,CAAC;AACtB,WAAK,WAAW,KAAK,CAAC;AAAA,IACxB,WAAW,gBAAgB,cAAc;AACvC,WAAK,gBAAgB;AAAA,IACvB,WAAW,SAAS,IAAI,GAAG;AACzB,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,WAAW;AAET,QAAI,CAAC,KAAK,gBAAgB;AACxB,WAAK,cAAc,QAAQ,KAAK,mBAAmB,KAAK,WAAW,CAAC,EAAE,UAAU,YAAU;AACxF,YAAI,WAAW,KAAK,UAAU;AAC5B,eAAK,UAAU;AAAA,QACjB,OAAO;AACL,eAAK,YAAY;AAAA,QACnB;AACA,aAAK,gBAAgB,aAAa;AAAA,MACpC,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY;AACV,SAAK,YAAY;AACjB,QAAI,KAAK,gBAAgB;AACvB,WAAK,eAAe,QAAQ,KAAK,UAAU,EAAE,GAAG,UAAU;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,SAAK,YAAY;AACjB,QAAI,KAAK,gBAAgB;AACvB,WAAK,eAAe,QAAQ,KAAK,UAAU,EAAE,GAAG,YAAY;AAAA,IAC9D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,SAAS;AAChB,SAAK,cAAc,SAAS,KAAK,UAAU,OAAO;AAAA,EACpD;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,yBAAyB,mBAAmB;AAC/D,aAAO,KAAK,qBAAqB,mBAAkB;AAAA,IACrD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,kBAAkB;AAAA,MAC9C,MAAM;AAAA,MACN,WAAW,CAAC,CAAC,IAAI,oBAAoB,EAAE,CAAC;AAAA,MACxC,UAAU;AAAA,MACV,cAAc,SAAS,8BAA8B,IAAI,KAAK;AAC5D,YAAI,KAAK,GAAG;AACV,UAAG,WAAW,SAAS,SAAS,4CAA4C;AAC1E,mBAAO,IAAI,SAAS;AAAA,UACtB,CAAC;AAAA,QACH;AACA,YAAI,KAAK,GAAG;AACV,UAAG,YAAY,UAAU,IAAI,SAAS,CAAC;AAAA,QACzC;AAAA,MACF;AAAA,MACA,QAAQ;AAAA,QACN,MAAM,CAAC,GAAG,oBAAoB,MAAM;AAAA,QACpC,UAAU;AAAA,QACV,QAAQ;AAAA,MACV;AAAA,MACA,UAAU,CAAC,kBAAkB;AAAA,IAC/B,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,kBAAkB,CAAC;AAAA,IACzF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,UAAU;AAAA,MACV,UAAU;AAAA,MACV,MAAM;AAAA,QACJ,kBAAkB;AAAA,QAClB,WAAW;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH,CAAC,GAAG,MAAM;AAAA,IACR,MAAM,CAAC;AAAA,MACL,MAAM;AAAA,MACN,MAAM,CAAC,kBAAkB;AAAA,IAC3B,CAAC;AAAA,IACD,UAAU,CAAC;AAAA,MACT,MAAM;AAAA,IACR,CAAC;AAAA,IACD,QAAQ,CAAC;AAAA,MACP,MAAM;AAAA,IACR,CAAC;AAAA,EACH,CAAC;AACH,GAAG;AAOH,IAAM,mBAAN,MAAM,kBAAiB;AAAA,EACrB,cAAc;AACZ,SAAK,gBAAgB,OAAO,mBAAmB;AAC/C,SAAK,cAAc,OAAO,UAAU;AACpC,SAAK,OAAO,oBAAI,IAAI;AACpB,SAAK,kBAAkB;AAAA,EACzB;AAAA,EACA,IAAI,UAAU,WAAW;AACvB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EACA,IAAI,UAAU;AACZ,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EACA,SAAS,UAAU,SAAS;AAC1B,SAAK,cAAc,SAAS,UAAU,OAAO;AAAA,EAC/C;AAAA,EACA,QAAQ,IAAI;AACV,WAAO,KAAK,KAAK,IAAI,EAAE;AAAA,EACzB;AAAA,EACA,kBAAkB;AAChB,SAAK,OAAO,QAAQ,KAAK,mBAAmB,KAAK,WAAW,CAAC,EAAE,UAAU,MAAM,KAAK,YAAY,CAAC;AACjG,SAAK,YAAY;AACjB,SAAK,cAAc,QAAQ,KAAK,mBAAmB,KAAK,WAAW,CAAC,EAAE,UAAU,cAAY;AAC1F,WAAK,iBAAiB,YAAY;AAClC,YAAM,OAAO,KAAK,KAAK,IAAI,QAAQ;AACnC,UAAI,MAAM;AACR,aAAK,UAAU;AACf,aAAK,kBAAkB;AAAA,MACzB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,cAAc;AACZ,SAAK,KAAK,MAAM;AAChB,aAAS,QAAQ,KAAK,QAAQ;AAC5B,WAAK,KAAK,IAAI,KAAK,UAAU,IAAI;AAAA,IACnC;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,yBAAyB,mBAAmB;AAC/D,aAAO,KAAK,qBAAqB,mBAAkB;AAAA,IACrD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,kBAAkB;AAAA,MAC9C,MAAM;AAAA,MACN,WAAW,CAAC,CAAC,IAAI,oBAAoB,EAAE,CAAC;AAAA,MACxC,gBAAgB,SAAS,gCAAgC,IAAI,KAAK,UAAU;AAC1E,YAAI,KAAK,GAAG;AACV,UAAG,eAAe,UAAU,kBAAkB,CAAC;AAAA,QACjD;AACA,YAAI,KAAK,GAAG;AACV,cAAI;AACJ,UAAG,eAAe,KAAQ,YAAY,CAAC,MAAM,IAAI,SAAS;AAAA,QAC5D;AAAA,MACF;AAAA,MACA,QAAQ;AAAA,QACN,WAAW,CAAC,GAAG,oBAAoB,WAAW;AAAA,MAChD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,kBAAkB,CAAC;AAAA,IACzF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,CAAC,GAAG,MAAM;AAAA,IACR,QAAQ,CAAC;AAAA,MACP,MAAM;AAAA,MACN,MAAM,CAAC,kBAAkB;AAAA,QACvB,aAAa;AAAA,MACf,CAAC;AAAA,IACH,CAAC;AAAA,IACD,WAAW,CAAC;AAAA,MACV,MAAM;AAAA,MACN,MAAM,CAAC,kBAAkB;AAAA,IAC3B,CAAC;AAAA,EACH,CAAC;AACH,GAAG;AAQH,IAAM,eAAN,MAAM,cAAa;AAAA,EACjB,cAAc;AACZ,SAAK,mBAAmB;AACxB,SAAK,WAAW,OAAO,mBAAmB;AAC1C,SAAK,iBAAiB,OAAO,UAAU,EAAE;AAMzC,SAAK,eAAe,KAAK,SAAS;AAAA,EACpC;AAAA,EACA,IAAI,OAAO,UAAU;AACnB,SAAK,mBAAmB;AACxB,SAAK,SAAS,QAAQ;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACX,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,UAAU;AACZ,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EACA,kBAAkB;AAChB,SAAK,SAAS,MAAM;AAAA,MAClB,gBAAgB,KAAK;AAAA,MACrB,MAAM,KAAK;AAAA,MACX,YAAY,KAAK;AAAA,MACjB,WAAW,KAAK;AAAA,OACZ,KAAK,oBAAoB;AAAA,MAC3B,iBAAiB,KAAK;AAAA,IACxB,EACD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,UAAU;AAC1B,SAAK,SAAS,QAAQ,SAAS,EAAE;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAIA,oBAAoB,UAAU;AAC5B,SAAK,SAAS,UAAU,SAAS,EAAE;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,UAAU,SAAS;AAC1B,SAAK,SAAS,SAAS,UAAU,kCAC3B,KAAK,kBAAkB;AAAA,MACzB,UAAU,KAAK;AAAA,IACjB,IACG,QACJ;AAAA,EACH;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,qBAAqB,mBAAmB;AAC3D,aAAO,KAAK,qBAAqB,eAAc;AAAA,IACjD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,kBAAkB;AAAA,MAC9C,MAAM;AAAA,MACN,WAAW,CAAC,CAAC,IAAI,gBAAgB,EAAE,CAAC;AAAA,MACpC,WAAW,CAAC,YAAY,KAAK,GAAG,cAAc,MAAM;AAAA,MACpD,QAAQ;AAAA,QACN,gBAAgB;AAAA,QAChB,YAAY;AAAA,QACZ,gBAAgB;AAAA,QAChB,WAAW;AAAA,QACX,QAAQ;AAAA,MACV;AAAA,MACA,SAAS;AAAA,QACP,cAAc;AAAA,MAChB;AAAA,MACA,UAAU,CAAC,cAAc;AAAA,MACzB,UAAU,CAAI,mBAAmB,CAAC,mBAAmB,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,cAAc,CAAC;AAAA,IACrF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,UAAU;AAAA,MACV,UAAU;AAAA,MACV,MAAM;AAAA,QACJ,UAAU;AAAA,QACV,OAAO;AAAA,MACT;AAAA,MACA,WAAW,CAAC,mBAAmB;AAAA,IACjC,CAAC;AAAA,EACH,CAAC,GAAG,MAAM;AAAA,IACR,gBAAgB,CAAC;AAAA,MACf,MAAM;AAAA,IACR,CAAC;AAAA,IACD,YAAY,CAAC;AAAA,MACX,MAAM;AAAA,IACR,CAAC;AAAA,IACD,gBAAgB,CAAC;AAAA,MACf,MAAM;AAAA,IACR,CAAC;AAAA,IACD,WAAW,CAAC;AAAA,MACV,MAAM;AAAA,IACR,CAAC;AAAA,IACD,QAAQ,CAAC;AAAA,MACP,MAAM;AAAA,IACR,CAAC;AAAA,IACD,cAAc,CAAC;AAAA,MACb,MAAM;AAAA,IACR,CAAC;AAAA,EACH,CAAC;AACH,GAAG;AAMH,IAAM,uBAAN,MAAM,sBAAqB;AAAA,EACzB,cAAc;AACZ,SAAK,cAAc,OAAO,UAAU;AACpC,SAAK,aAAa,OAAO,YAAY;AAAA,EACvC;AAAA,EACA,kBAAkB;AAChB,SAAK,WAAW,kBAAkB,IAAI;AACtC,SAAK,YAAY,UAAU,MAAM,KAAK,WAAW,oBAAoB,IAAI,CAAC;AAAA,EAC5E;AAAA,EACA,OAAO;AACL,SAAK,OAAO,SAAS,6BAA6B,mBAAmB;AACnE,aAAO,KAAK,qBAAqB,uBAAsB;AAAA,IACzD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,kBAAkB;AAAA,MAC9C,MAAM;AAAA,MACN,WAAW,CAAC,CAAC,IAAI,wBAAwB,EAAE,CAAC;AAAA,MAC5C,UAAU;AAAA,MACV,cAAc,SAAS,kCAAkC,IAAI,KAAK;AAChE,YAAI,KAAK,GAAG;AACV,UAAG,cAAc,MAAM,IAAI,EAAE;AAAA,QAC/B;AAAA,MACF;AAAA,MACA,QAAQ;AAAA,QACN,IAAI,CAAC,GAAG,wBAAwB,IAAI;AAAA,MACtC;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,sBAAsB,CAAC;AAAA,IAC7F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,UAAU;AAAA,MACV,MAAM;AAAA,QACJ,QAAQ;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH,CAAC,GAAG,MAAM;AAAA,IACR,IAAI,CAAC;AAAA,MACH,MAAM;AAAA,MACN,MAAM,CAAC,sBAAsB;AAAA,IAC/B,CAAC;AAAA,EACH,CAAC;AACH,GAAG;AACH,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EACvB,OAAO;AACL,SAAK,OAAO,SAAS,2BAA2B,mBAAmB;AACjE,aAAO,KAAK,qBAAqB,qBAAoB;AAAA,IACvD;AAAA,EACF;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,iBAAiB;AAAA,MAC7C,MAAM;AAAA,MACN,SAAS,CAAC,cAAc,kBAAkB,sBAAsB,gBAAgB;AAAA,MAChF,SAAS,CAAC,cAAc,kBAAkB,sBAAsB,gBAAgB;AAAA,IAClF,CAAC;AAAA,EACH;AAAA,EACA,OAAO;AACL,SAAK,OAAyB,iBAAiB,CAAC,CAAC;AAAA,EACnD;AACF;AAAA,CACC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,oBAAoB,CAAC;AAAA,IAC3F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,SAAS,CAAC,cAAc,kBAAkB,sBAAsB,gBAAgB;AAAA,MAChF,SAAS,CAAC,cAAc,kBAAkB,sBAAsB,gBAAgB;AAAA,IAClF,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;",
  "names": ["fragment"]
}
